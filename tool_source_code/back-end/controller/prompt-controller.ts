import _ from 'underscore'
import * as http from '../http-protocol'
import * as gpt from '../openai'
import * as bn from '../business'
import * as util from '../util'
import fs from 'fs'

export class PromptController {
  private createParams(
    _name: string,
    _description: string,
    _prompt: string,
    files: bn.FilePage[],
    _context: string | null = null
  ): gpt.Hash {
    const _history: string[] = []

    if (files && files.length > 0) {
      _history.push('File codes generated by ChatGPT:\n')
      for (const f of files) {
        _history.push(`File Path: ${f.path}\nFile Content:\n\`\`\`${f.type}\n${f.content}\n\`\`\`\n\n`)
      }
    }

    const params: gpt.Hash = {
      prompt: _prompt,
      history: _history.join('') || '',
      'file-name': _name,
      description: _description,
      'api-rest': _name.toLowerCase(),
      context: _context ? _context : ''
    }

    return params
  }

  private createMessages(pt: bn.PromptType | null, params: gpt.Hash): gpt.MessagePrompt[] {
    if (pt && pt.messageUser) {
      params['prompt'] = pt.messageUser + '\n' + params['prompt']
    }
    const rs: gpt.MessagePrompt[] = []

    const user: gpt.MessagePrompt = { message: `{prompt}`, params: params }
    rs.push(user)

    const system: gpt.MessagePrompt | null = pt?.messageSystem ? { message: pt?.messageSystem, params: params } : null
    if (system) {
      rs.push(system)
    }

    const assistent: gpt.MessagePrompt | null = params['history'] ? { message: `{history}`, params: params } : null
    if (assistent) {
      rs.push(assistent)
    }

    return rs
  }

  async listTypes(): Promise<http.Response> {
    const result: http.Response = http.defaultResponse()

    const _ls: bn.PromptType[] = await bn.PromptType.list()
    result.content = {
      list: _ls.map((_pt: bn.PromptType): { id: number; name: string } => {
        return { id: _pt.id, name: _pt.name }
      })
    }
    return result
  }

  private async saveFilePage(_content: string, _page: bn.Page, _requestId: number): Promise<bn.FilePage[]> {
    const code: util.Code[] = util.fnCodeLanguage(_content, _page.name)

    const files: bn.FilePage[] = []

    for await (const c of code) {
      const _fp: bn.FilePage = new bn.FilePage(_page.id, _requestId, c.path, c.name, c.language, c.content)
      await _fp.save()

      files.push(_fp)
    }

    return files
  }

  async fnPutPrompt(_pageId: number, _body: { chat: string; type: number }, _username: string): Promise<http.Response> {
    const result: http.Response = http.defaultResponse()
    result.content = { ok: false }

    if (_pageId > 0 && !_.isEmpty(_body.chat) && _body.type > 0) {
      const _pg: bn.Page | null = await bn.Page.get(_pageId)

      if (_pg) {
        const pt: bn.PromptType | null = await bn.PromptType.get(_body.type)
        const _sysContext: bn.SystemContext | null = await bn.SystemContext.getByUsername(_username)
        const _context: string = _sysContext ? _sysContext.context : ''

        const _files: bn.FilePage[] = _body.type > 1 ? await bn.FilePage.listAllSystem(_username, _pageId) : []

        const ft1: bn.FileTemplate = await bn.FileTemplate.get(1)
        if (!fs.existsSync(ft1.path)) {
          _files.push(
            new bn.FilePage(_pg.id, 0, ft1.path, '', 'typescript', util.readContentFileSync(_username, ft1.path))
          )
        }

        const ft2: bn.FileTemplate = await bn.FileTemplate.get(2)
        if (!fs.existsSync(ft2.path)) {
          _files.push(
            new bn.FilePage(_pg.id, 0, ft2.path, '', 'typescript', util.readContentFileSync(_username, ft2.path))
          )
        }

        const params = this.createParams(_pg.name, _pg.description, _body.chat, _files, _context)
        const messages: gpt.MessagePrompt[] = this.createMessages(pt, params)

        const contentRequestFull: string = new gpt.FormatString(
          `## System:\n{systemMessage}\n## Assistent:\n{assistentMessage}\n## User:\n{userMessage}`
        ).formatKey({
          userMessage: new gpt.FormatString(messages[0].message).formatKey(messages[0].params),
          systemMessage: new gpt.FormatString(messages[1]?.message).formatKey(messages[1]?.params),
          assistentMessage: new gpt.FormatString(messages[2]?.message).formatKey(messages[2]?.params)
        })

        const r: bn.PromptRequest = new bn.PromptRequest(_pageId, _body.chat, _body.type, contentRequestFull)
        r.id = await r.save()
        _pg.updateRequestId(r.id)

        if (_body.type == 1) {
          const ft5: bn.FileTemplate = await bn.FileTemplate.get(5)
          const _pathFT5: string = new gpt.FormatString(ft5.path).formatKey({
            name: _pg.name,
            name_lowercase: _pg.name.toLowerCase()
          })
          if (!fs.existsSync(_pathFT5)) {
            util.writeContentFileSync(_username, _pathFT5, null, ft5.content)
          }

          const ft6: bn.FileTemplate = await bn.FileTemplate.get(6)
          const _pathFT6: string = new gpt.FormatString(ft6.path).formatKey({
            name: _pg.name,
            name_lowercase: _pg.name.toLowerCase()
          })
          if (!fs.existsSync(_pathFT6)) {
            util.writeContentFileSync(_username, _pathFT6, null, ft6.content)
          }
        }

        const contentResponse: string = await util.fnSendOpenAI(r, messages[0], messages[1], messages[2])

        const files: bn.FilePage[] = await this.saveFilePage(contentResponse, _pg, r.id)

        for (const f of files) {
          util.writeContentFileSync(_username, f.path, null, f.content)
        }

        util.restartCommand(_username)

        result.content = { ok: true }
      }
    }

    return result
  }
}
